import Lean
import Solver.Command.Tactic

namespace Test.SmtPredQualifier

/-! ## Test objectives to validate predicate qualifiers generated during smt translation -/

#solve [ ∀ (xs : List Nat), !(List.isEmpty xs) → List.head! (List.map Int.ofNat xs) ≥ 0 ]

inductive NatGroup where
 | first (n : Nat) (h1 : n ≥ 10) (h2 : n < 100): NatGroup
 | second (n : Nat) (h1 : n > 100) (h2 : n < 200) : NatGroup
 | next (n : NatGroup)

def isFirst (x : NatGroup) : Bool :=
  match x with
  | .first .. => true
  | _ => false

def isSecond (x : NatGroup) : Bool :=
  match x with
  | .second .. => true
  | _ => false


def toFirst (x : NatGroup) : Nat :=
  match x with
  | .first n _ _ => n
  | _ => 0

def toSecond (x : NatGroup) : Nat :=
  match x with
  | .second n _ _ => n
  | _ => 0

def isNextFirst (x : NatGroup) : Bool :=
  let rec visit (x : NatGroup) : Bool :=
    match x with
    | .first .. => true
    | .second .. => false
    | .next n => visit n
  match x with
  | .next n => visit n
  | _ => false

def toNextFirst (x : NatGroup) : Nat :=
  let rec visit (x : NatGroup) : Nat :=
    match x with
    | .first n _ _ => n
    | .second .. => 0
    | .next n => visit n
  match x with
  | .next n => visit n
  | _ => 0

#solve [ ∀ (x : NatGroup), isFirst x → let r := toFirst x; r ≥ 10 ∧ r < 100 ]

#solve [ ∀ (x : NatGroup), isSecond x → let r := toSecond x; r > 100 ∧ r < 200 ]


--- NOTE: remove solver options when proof by induction is automated
#solve (timeout: 2) (solve-result: 2)
  [ ∀ (x : NatGroup), isNextFirst x → let r := toNextFirst x; r ≥ 10 ∧ r < 100 ]

-- NOTE: The following corresponds to the induction schema subgoals generated by Lean4 and proved
-- using the blaster tactic.
set_option warn.sorry false in
theorem nextFirst_spec : ∀ (x : NatGroup), isNextFirst x → let r := toNextFirst x; r ≥ 10 ∧ r < 100 := by
  intro x
  induction x <;> blaster

abbrev IdentName := String

mutual
  inductive Attribute (α : Type u) where
  | Named (n : IdentName)
  | Pattern (p : List (Term α))
  | Qid (n : IdentName) (p : Except (Option (Term α)) (List (Attribute α)))

  inductive Term (α : Type u) where
  | Ident (s : IdentName)
  | Seq (x : List α)
  | App (nm : IdentName) (args : List (Term α))
  | Annotated (t : Term α) (annot : List (Attribute α))
end

#solve [ (∀ (β : Type) (x : Term (List β)) (f : Term (List β) → Nat), f x > 10) →
         (∀ (α : Type) (x y : Term (List α)) (f : Term (List α) → Nat), f x + f y > 20)
       ]

#solve [ (∀ (β : Type) (x : Term (List β)) (g : Term (List β) → Nat), g x > 10) →
         (∀ (α : Type) (x y : Term (List α)) (f : Term (List α) → Nat), f x + f y > 20)
       ]

inductive Either (α : Type u) (β : Type v) where
 | Left : α -> Either α β
 | Right : β -> Either α β

instance [BEq a] [BEq b] : BEq (Either a b) where
  beq | Either.Left a1, Either.Left a2 => a1 == a2
      | Either.Right b1, Either.Right b2 => b1 == b2
      | _, _ => false

#solve
  [ (∀ (α : Type) (a b : α), [BEq α] → a == b → a = b) →
      (∀ (α : Type) (β : Type) (x y : Either α β), [BEq α] → [BEq β] → x == y → x = y)
  ]


/-! # Test cases to ensure that counterexample are properly detected -/

def sizeOfTerm (t : Term α) : Nat :=
  match t with
  | .Ident _ => 1
  | .Seq xs => List.length xs
  | .App _ args => List.length args
  | .Annotated t' _ => 1 + sizeOfTerm t'

#solve (gen-cex:0) (solve-result: 1) (random-seed: 1) [ ∀ (α : Type) (x : Term α), sizeOfTerm x < 10 ]

#solve (gen-cex: 0) (solve-result: 1)
  [ ∀ (xs : List Nat), !(List.isEmpty xs) → List.head! (List.map Int.ofNat xs) ≥ 10 ]


#solve (gen-cex: 0) (solve-result: 1)
  [ ∀ (x : NatGroup), isFirst x → let r := toFirst x; r > 20 ∧ r < 100 ]

#solve (gen-cex: 0) (solve-result: 1)
  [ ∀ (x : NatGroup), isSecond x → let r := toSecond x; r > 200 ∧ r < 300 ]

#solve (gen-cex: 0) (solve-result: 1)
  [ (∀ (x : NatGroup), isNextFirst x → let r := toNextFirst x; r > 20 ∧ r < 100) ]

#solve (gen-cex: 0) (solve-result: 1)
  [ (∀ (α : Type) (x y : Term (List α)) (f : Term (List α) → Nat), f x + f y > 10) ]

#solve (gen-cex: 0) (solve-result: 1)
  [ (∀ (α : Type) (β : Type) (x y : Either α β), [BEq α] → [BEq β] → x == y → x = y) ]


end Test.SmtPredQualifier
